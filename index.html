<body></body>
<script src="https://unpkg.com/tone"></script>
<script src="https://cdn.jsdelivr.net/gh/netizenorg/netnet-standard-library/build/nn.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://algorithmicmusic.online/js/create-spectrum.js"></script>
<script src="https://algorithmicmusic.online/js/create-waveform.js"></script>
<script>
/* global Tone, nn, d3, createWaveform, createSpectrum */

// declaring globals
let theremin = false
let intervalS
let currRate = 40
let vol = -10
const RATEMAX = 1
const MAXMAX = 1
let partials = []
let paused = false

// synth
const synth = new Tone.PolySynth(Tone.Synth, {maxPolyphony: 12})
synth.set({
  oscillator: {
    type: 'custom',
    partials: [1, 0, 0, 0, 0, 0, 0, 0, 0],
    volume: vol
  },
  envelope: {
    attack: 0.005,
    decay: 0.2,
    sustain: 0.4,
    release: 1
  }
})
const filter1 = new Tone.Filter({
  type: "lowshelf",
  frequency: "C4",
  gain: 10
})
const filter2 = new Tone.Filter({
  type: "lowshelf",
  frequency: "C5",
  gain: 1
})
const filter3 = new Tone.Filter({
  type: "highshelf",
  frequency: "C5",
  gain: -10
})
const filter4 = new Tone.Filter({
  type: "highshelf",
  frequency: "C6",
  gain: -10
})
synth.connect(filter1)
filter1.connect(filter2)
filter2.connect(filter3)
filter3.connect(filter4)
filter4.toDestination()

// html stuff  
//title
nn.create('title')
  .content('[false choir]')
  .addTo('body')
nn.create('text')
  .content('[false choir]')
  .addTo('body')
//wave&spectrum
const wave = createWaveform()
synth.connect(wave)
const spec = createSpectrum({ range: [20, 7040] })
synth.connect(spec)
//buttons
const buttons = nn.create('section').addTo('body')
//sliders
nn.create('br').addTo('body')
const sliders = nn.create('section').addTo('body')
nn.create('br').addTo('body')
//theremin
function toggleT(e) {
  if (e.target.checked) { theremin = true }
  else { theremin = false }
}
nn.create('input').addTo('body')
  .set({ type: 'checkbox' })
  .on('change', toggleT)
nn.create('text').addTo('body')
  .content('toggle theremin controls')
nn.create('br').addTo('body')
//disclaimer
nn.create('br').addTo('body')
nn.create('text')
  .content('(midi recommended)')
  .addTo('body')
nn.create('br').addTo('body')
//credits
nn.create('br').addTo('body')
nn.create('text')
  .content('[by austin xie]')
  .addTo('body')
  
// partial class
  
class Partial {
  constructor() {
    this.p = 0
    this.rate = 0
    this.rising = true
    this.max = 1
    this.on = false
    this.rateLabel = null
    this.maxLabel = null
    this.rateInput = null
    this.maxInput = null
    this.num = 0
    
    this.updateRate = this.updateRate.bind(this)
    this.updateRateLabel = this.updateRateLabel.bind(this)
    this.updateMax = this.updateMax.bind(this)
    this.updateMaxLabel = this.updateMaxLabel.bind(this)
    this.update = this.update.bind(this)
  }
  updateRate(e) {
    this.rate = Number(e.target.value)
    this.updateRateLabel()
  }
  updateRateLabel() {
    this.rateLabel.content(`rate:  ${this.rate.toFixed(2)}  `)
  }
  updateMax(e) {
    this.max = Number(e.target.value)
    this.updateMaxLabel()
  }
  updateMaxLabel() {
    this.maxLabel.content(`max:  ${this.max.toFixed(2)}  `)
  }
  update() {
    if (this.rising && this.p + this.rate > this.max) {
      this.rising = false
      this.p = this.max
    }
    else if (!this.rising && this.p - this.rate < 0) {
      this.rising = true
      this.p = 0
    }
    else if (this.rising) {
      this.p = (this.p + this.rate) * this.max
    }
    else {
      this.p = (this.p - this.rate) * this.max
    }
    updateSynth()
    if (this.on) {
      setTimeout(this.update, currRate)
    }
  }
}

// partial object creations
const p1 = new Partial()
const p2 = new Partial()
const p3 = new Partial()
const p4 = new Partial()
const p5 = new Partial()
const p6 = new Partial()
const p7 = new Partial()
const p8 = new Partial()
partials = [p1, p2, p3, p4, p5, p6, p7, p8]
  
// slider creation
for (let p = 0; p < partials.length; p++) {
  // rate label
  let tempp = partials[p]
  nn.create('text')
    .content('p' + String(p + 1) + '  ')
    .addTo(sliders)
  tempp.num = p + 1
  tempp.rateLabel = nn.create('label')
    .content('rate:  0.00  ')
    .addTo(sliders)
  // rate input
  tempp.rateInput = nn.create('input')
    .set({ type: 'range', value: 0, min: 0, max: RATEMAX, step: "any" })
    .addTo(sliders)
    .on('input', tempp.updateRate)
  // space between rate and max
  nn.create('text')
    .content('  ')
  .addTo(sliders)
  // max label
  nn.create('text')
    .content('p' + String(p + 1) + '  ')
    .addTo(sliders)
  tempp.maxLabel = nn.create('label')
    .content('max:  1.00  ')
    .addTo(sliders)
  // max input
  tempp.maxInput = nn.create('input')
    .set({ type: 'range', value: 0, min: 0, max: MAXMAX, step: "any" })
    .addTo(sliders)
    .on('input', tempp.updateMax)
  tempp.maxInput.value = 1
  // ending line break
  nn.create('br').addTo(sliders)
}

// partial oscillation functions
function initLoops() {
  for (let p = 0; p < partials.length; p++) {
    partials[p]["on"] = true
    partials[p].update()
  }
}

function clearLoops() {
  for (let p = 0; p < partials.length; p++) {partials[p]["on"] = false}
}

function updateSynth() {
    synth.set({"oscillator": {"type": 'custom',
        "partials": [1, p1.p, p2.p, p3.p, p4.p, p5.p, p6.p, p7.p, p8.p]}
    })
}
  
function resetPartials() {
  p1.p = 0; p2.p = 0; p3.p = 0; p4.p = 0; p5.p = 0; p6.p = 0; p7.p = 0; p8.p = 0 
  updateSynth()
}

// buttons creation
nn.create('button')
  .content('pause partials')
  .addTo(buttons)
  .on('click', () => {paused = true; clearLoops()})
nn.create('text')
  .content('          ')
  .addTo(buttons)
nn.create('button')
  .content('resume partials')
  .addTo(buttons)
  .on('click', () => {paused = false; initLoops()})
nn.create('text')
  .content('          ')
  .addTo(buttons)
nn.create('button')
  .content('reset partials')
  .addTo(buttons)
  .on('click', resetPartials)
nn.create('br').addTo(buttons)
  
// mapping keyboard buttons to notes
const keyMap = {
  '`': { note: "C3", pressed: false },
  '1': { note: "C#3", pressed: false },
  'q': { note: "D3", pressed: false },
  '2': { note: "D#3", pressed: false },
  'w': { note: "E3", pressed: false },
  'e': { note: "F3", pressed: false },
  '4': { note: "F#3", pressed: false },
  'r': { note: "G3", pressed: false },
  '5': { note: "G#3", pressed: false },
  't': { note: "A3", pressed: false },
  '6': { note: "A#3", pressed: false },
  'y': { note: "B3", pressed: false },
  'u': { note: "C4", pressed: false },
  '8': { note: "C#4", pressed: false },
  'i': { note: "D4", pressed: false },
  '9': { note: "D#4", pressed: false },
  'o': { note: "E4", pressed: false },
  'p': { note: "F4", pressed: false },
  '-': { note: "F#4", pressed: false },
  '[': { note: "G4", pressed: false },
  '=': { note: "G#4", pressed: false },
  ']': { note: "A4", pressed: false },
  'Backspace': { note: "A#4", pressed: false },
  '\\': { note: "B4", pressed: false },
  'z': { note: "C5", pressed: false },
  's': { note: "C#5", pressed: false },
  'x': { note: "D5", pressed: false },
  'd': { note: "D#5", pressed: false },
  'c': { note: "E5", pressed: false },
  'v': { note: "F5", pressed: false },
  'g': { note: "F#5", pressed: false },
  'b': { note: "G5", pressed: false },
  'h': { note: "G#5", pressed: false },
  'n': { note: "A5", pressed: false },
  'j': { note: "A#5", pressed: false },
  'm': { note: "B5", pressed: false },
  ',': { note: "C6", pressed: false },
  'l': { note: "C#6", pressed: false },
  '.': { note: "D6", pressed: false },
  ';': { note: "D#6", pressed: false },
  '/': { note: "E6", pressed: false }
}

// keyboard controls
function keyStart(e) {
  const obj = keyMap[e.key]
  if (obj && !obj.pressed) {
    synth.triggerAttack(obj.note)
    obj.pressed = true
    if (!paused) {
      initLoops()
    }
  }
}

function release(e) {
  const obj = keyMap[e.key]
  if (obj && obj.pressed) {
    synth.triggerRelease(obj.note)
    obj.pressed = false
  }
}
  
// MIDI controls
function updatePartials(msg) {
  if (msg.chl < 8) {
    if (msg.chl === 0) {
      p1.rate = nn.map(msg.val, 0, 127, 0, RATEMAX)
      p1.updateRateLabel()
    }
    else if (msg.chl === 1) {
      p2.rate = nn.map(msg.val, 0, 127, 0, RATEMAX)
      p2.updateRateLabel()
    }
    else if (msg.chl === 2) {
      p3.rate = nn.map(msg.val, 0, 127, 0, RATEMAX)
      p3.updateRateLabel()
    }
    else if (msg.chl === 3) {
      p4.rate = nn.map(msg.val, 0, 127, 0, RATEMAX)
      p4.updateRateLabel()
    }
    else if (msg.chl === 4) {
      p5.rate = nn.map(msg.val, 0, 127, 0, RATEMAX)
      p5.updateRateLabel()
    }
    else if (msg.chl === 5) {
      p6.rate = nn.map(msg.val, 0, 127, 0, RATEMAX)
      p6.updateRateLabel()
    }
    else if (msg.chl === 6) {
      p7.rate = nn.map(msg.val, 0, 127, 0, RATEMAX)
      p7.updateRateLabel()
    }
    else if (msg.chl === 7) {
      p8.rate = nn.map(msg.val, 0, 127, 0, RATEMAX)
      p8.updateRateLabel()
    }
  }
  else if (msg.chl < 23) {
    if (msg.chl === 16) {
      p1.max = nn.map(msg.val, 0, 127, 0, MAXMAX)
      p1.updateMaxLabel()
    }
    else if (msg.chl === 17) {
      p2.max = nn.map(msg.val, 0, 127, 0, MAXMAX)
      p2.updateMaxLabel()
    }
    else if (msg.chl === 18) {
      p3.max = nn.map(msg.val, 0, 127, 0, MAXMAX)
      p3.updateMaxLabel()
    }
    else if (msg.chl === 19) {
      p4.max = nn.map(msg.val, 0, 127, 0, MAXMAX)
      p4.updateMaxLabel()
    }
    else if (msg.chl === 20) {
      p5.max = nn.map(msg.val, 0, 127, 0, MAXMAX)
      p5.updateMaxLabel()
    }
    else if (msg.chl === 21) {
      p6.max = nn.map(msg.val, 0, 127, 0, MAXMAX)
      p6.updateMaxLabel()
    }
    else if (msg.chl === 22) {
      p7.max = nn.map(msg.val, 0, 127, 0, MAXMAX)
      p7.updateMaxLabel()
    }
    else if (msg.chl === 23) {
      p8.max = nn.map(msg.val, 0, 127, 0, MAXMAX)
      p8.updateMaxLabel()
    }
  }
  else if (msg.chl === 42 && msg.val === 127) {paused = true; clearLoops()}
  else if (msg.chl === 41 && msg.val === 127) {paused = false; initLoops()}
  else if (msg.chl === 45 && msg.val === 127) {resetPartials()}
}

// theremin control functions
let thereminNote
function start() {
  if (theremin) {
    thereminNote = freqRaw
    synth.triggerAttack(thereminNote)
    if (!paused) {
      initLoops()
    }
  }
}
function stop() {
  if (theremin) {  
    synth.triggerRelease(thereminNote)
    clearLoops()
  }
}
function mouseUpdate (e) {
  if (theremin) {
    freqRaw = nn.map(e.x, 0, nn.width, 220, 1000)
    synth.set({
      "oscillator": {
        "frequency": freqRaw,
        "volume": nn.map(e.y, 0, nn.height, 0, -25)
      }
    })
  }
}
  
// netnet input handling
//theremin
nn.on('mousedown', start)
nn.on('mouseup', stop)
nn.on('mousemove', mouseUpdate)
//keyboard
nn.on('keydown', keyStart)
nn.on('keyup', release)
//MIDI
nn.MIDI(updatePartials)

</script>